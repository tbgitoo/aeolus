// ----------------------------------------------------------------------
//
//  Copyright (C) 2003-2010 Fons Adriaensen <fons@linuxaudio.org>
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
//
// Thomas Brachler and Mathis Braschler 2025: Comments in part generated by claude.ai
// ----------------------------------------------------------------------


#ifndef AEOLUS_RNGEN_H
#define	AEOLUS_RNGEN_H


#include "prbsgen.h"

/**
 * @brief Random number generator class implementing a lagged Fibonacci generator
 *
 * This class implements a lagged Fibonacci generator (LFG) with lag parameters (55, 24).
 * It provides both uniform and Gaussian (normal) distributed random numbers in both
 * double and float precision. The generator uses the recurrence relation:
 * X(n) = X(n-55) + X(n-24) mod 2^32
 *
 * @note This class uses the copy constructor and assignment operator as private
 *       and unimplemented to prevent copying of the generator state.
 */
class Rngen
{
public:
    /**
     * @brief Default constructor
     *
     * Constructs a new random number generator. The generator must be initialized
     * with a seed using init() before use.
     */
    Rngen ();

    /**
     * @brief Initialize the random number generator with a seed
     *
     * Seeds the generator and fills the internal state array. This function
     * must be called before generating any random numbers.
     *
     * @param seed The seed value for initialization (32-bit unsigned integer)
     */
    void init (uint32_t seed);

    /**
     * @brief Generate a uniform random 32-bit integer
     *
     * Generates the next random number in the sequence using the lagged
     * Fibonacci generator algorithm. This is the core generation function
     * used by all other random number methods.
     *
     * @return A uniformly distributed 32-bit unsigned integer
     */
    uint32_t irand (void)
    {
        uint32_t r;

        if (++_i == 55) _i = 0;
        if (_i < 24) r = _a [_i] += _a [_i + 31];
        else         r = _a [_i] += _a [_i - 24];
        return r;
    }

    /**
     * @brief Generate a uniform random double in [0,1)
     *
     * @return A uniformly distributed double-precision floating point number
     *         in the range [0, 1)
     */
    double  urand () { return irand () / _p32; }
    /**
     * @brief Generate a Gaussian (normal) distributed random double
     *
     * Generates a random number from a standard normal distribution
     * (mean=0, variance=1) using double precision.
     *
     * @return A normally distributed double-precision floating point number
     */
    double  grand ();
    /**
   * @brief Generate a pair of independent Gaussian distributed random doubles
   *
   * Efficiently generates two independent normally distributed random numbers
   * using the Box-Muller transform (on the radius, c.f. for example
   * https://www.cl.cam.ac.uk/teaching/0708/Probabilty/prob12.pdf)
   *
   * @param[out] x Pointer to store the first random number
   * @param[out] y Pointer to store the second random number
   */
    void    grand (double *x, double *y);
    /**
     * Uniform random distribution, interval 0-1
     * @return single sample of a uniform random number in the interval 0-1
     */
    float   urandf () { return irand () / _p32f; }
    /**
     * Normally distributed float random variable
     * @return
     */
    float   grandf ();
    /**
     * Bi-normal distributed float random variables
     * return through pointers x and y
     */
    void    grandf (float  *x, float *y);

    ~Rngen (void);
    Rngen (const Rngen&);           // disabled, not to be used
    Rngen& operator=(const Rngen&); // disabled, not to be used

private:

    uint32_t  _a [55]; // keep track of the last 55 numbers for random numbers generation
    int       _i; // current position in the circular buffer
    bool      _md; // do we already have a second normally distributed double variable? (They are geneerated in pairs)
    bool      _mf; // do we already have a second normally distributed float variable? (They are generated in pairs)
    double    _vd; // second double value for normally distributed random variable
    float     _vf; // second float vale for normally distributed random variable

    static const double  _p31; //2^31
    static const double  _p32; // 2^32
    static const float   _p31f; // 2^31
    static const float   _p32f; // 2^32
};


#endif
